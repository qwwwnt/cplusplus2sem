1. Алгоритм find(first, last, val) осуществляет линейный поиск значения val от итератора first до итератора last
sort(first, last) - упорядочивает элементы контейнера по неубыванию.
reverse(first, last) - разворачивает фрагмент контейнера в обратном порядке, переставляя элементы, равноудаленные от концов.
next_permutation(first, last) - переставляет элементы так, чтобы получилась следующая в лексикографическом порядке перестановка.
random_shuffle(first, last) - делает случайную перестановку элементов контейнера.
count(first, last, val)  -- подсчитывает сколько элементов контейнера равны значению val.
max_element(first, last) возвращает итератор на наибольший элемент.

2. Итератор — это объект, разработанный для перебора элементов контейнера, обеспечивающий во время перемещения по элементам доступ к каждому из них.
Операции с итераторами:
*iter: получение элемента, на который указывает итератор
++iter: перемещение итератора вперед для обращения к следующему элементу
--iter: перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента.
iter1 == iter2: два итератора равны, если они указывают на один и тот же элемент
iter1 != iter2: два итератора не равны, если они указывают на разные элементы
iter + n: возвращает итератор, который смещен от итератора iter на n позиций вперед
iter - n: возвращает итератор, который смещен от итератора iter на n позиций назад
iter += n: перемещает итератор на n позиций вперед
iter -= n: перемещает итератор на n позиций назад
iter1 - iter2: возвращает количество позиций между итераторами iter1 и iter2
>, >=, <, <=: операции сравнения.

3.
Пара итераторов задаёт диапазон — определение последовательности значений, которую можно перечислить, передвигая итератор вперёд, начиная с первого элемента, на который указывает первый итератор в паре, и до тех пор, пока не будет встречен второй итератор в паре, обозначающий конец последовательности.

4.
#include <iostream>
#include <random>
#include <ctime>
int main() {
  std::mt19937 engine; 
  engine.seed(std::time(nullptr));
  int val = engine(); 
  std::cout << val;
}

5. 
Последовательные контейнеры